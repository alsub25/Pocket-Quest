<div align="center">

# ğŸŒ² Emberwood: The Blackbark Oath âš”ï¸

### *A Browser-Based Fantasy RPG & Village Simulation*

[![Version](https://img.shields.io/badge/version-v1.2.70-brightgreen.svg)](https://github.com/alsub25/Emberwood-The-Blackbark-Oath)
[![License](https://img.shields.io/badge/license-See%20LICENSE-blue.svg)](#license)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](#contributing-guidelines)
[![No Build Required](https://img.shields.io/badge/build-not%20required-success.svg)](#quick-start)

**[Play Now](https://alsub25.github.io/Emberwood-The-Blackbark-Oath/) â€¢ [Report Bug](https://github.com/alsub25/Emberwood-The-Blackbark-Oath/issues) â€¢ [Request Feature](https://github.com/alsub25/Emberwood-The-Blackbark-Oath/issues)**

---

</div>

## ğŸ® About The Game

**Emberwood: The Blackbark Oath** is a rich single-page browser RPG that combines deep turn-based combat with an immersive village simulation. Your **daily decisions**â€”from resting at the tavern to managing finances at the bank, influencing local politics, and taking on dangerous questsâ€”ripple through a living, breathing settlement.

> **Current Patch:** v1.2.70 â€” *The Blackbark Oath â€” Hardening & Bug Squash*  
> ğŸ“œ **In-game changelog:** Open **Changelog** from the main menu

### âœ¨ Key Features

This repository is intentionally **no-build** and **static-host friendly**:

- ğŸŒ **Runs entirely in the browser** â€” No backend required
- ğŸ“¦ **Native ES modules** â€” No bundler, no build step
- ğŸ’¾ **Local saves** â€” Persists via `localStorage` (single-player, device-local)
- ğŸ› ï¸ **Developer tools included** â€” Smoke Tests, Scenario Runner, Bug Report bundle for testing and balancing
- ğŸ¯ **Pure JavaScript** â€” Easy to understand, modify, and extend
- ğŸ“± **Mobile-friendly** â€” iOS Safari compatible with special guards

---

## ğŸ“š Table of Contents

<details>
<summary><b>Click to expand</b></summary>

- [ğŸ® About The Game](#-about-the-game)
- [ğŸ¯ Gameplay Highlights](#-gameplay-highlights)
- [ğŸš€ Quick Start](#-quick-start)
- [ğŸŒ Deploy to GitHub Pages](#-deploy-to-github-pages)
- [ğŸ“‚ Project Layout](#-project-layout)
- [ğŸ—ï¸ Architecture Overview](#ï¸-architecture-overview)
- [âš™ï¸ Gameplay Systems](#ï¸-gameplay-systems)
  - [State Model & Save Schema](#state-model--save-schema)
  - [Time System & Daily Ticks](#time-system--daily-ticks)
  - [RNG & Determinism](#rng--determinism)
  - [Combat](#combat)
  - [Abilities & Effects](#abilities--effects)
  - [Status Effects & Synergies](#status-effects--synergies)
  - [Elements, Affinities & Resistances](#elements-affinities--resistances)
  - [Classes, Resources & Progression](#classes-resources--progression)
  - [Talents](#talents)
  - [Items, Inventory & Equipment](#items-inventory--equipment)
  - [Loot Generation](#loot-generation)
  - [Enemies, Rarity & Affixes](#enemies-rarity--affixes)
  - [Quests](#quests)
  - [Village Simulation](#village-simulation)
  - [Logging & UI](#logging--ui)
  - [Diagnostics & QA Tools](#diagnostics--qa-tools)
- [â• Adding Content](#-adding-content)
- [ğŸ§ª Testing & Debugging](#-testing--debugging)
- [ğŸ¤ Contributing Guidelines](#-contributing-guidelines)
- [ğŸ“‹ Versioning & Releases](#-versioning--releases)
- [ğŸ“œ License](#-license)

</details>

---

## ğŸ¯ Gameplay Highlights

<table>
<tr>
<td width="50%">

### âš”ï¸ **Combat & Character Building**
- ğŸ­ **9 Unique Classes** â€” Mage, Warrior, Rogue, Ranger, Blood Knight, Cleric, Berserker, Vampire, Necromancer
- ğŸ’« **Deep Ability System** â€” Unlock powerful spells and skills as you level up
- ğŸŒŸ **Talent Trees** â€” Customize your playstyle with passive bonuses
- ğŸ² **Turn-Based Combat** â€” Strategic battles with enemy intents and combo systems
- ğŸ”¥ **Elemental Synergies** â€” Combine fire, ice, and other elements for devastating effects
- âš¡ **Status Effects** â€” Bleed, Burn, Chill, Poison, and many more

</td>
<td width="50%">

### ğŸ° **Village Life & Economy**
- ğŸª **Merchant System** â€” Buy and sell items, with dynamic stock and pricing
- ğŸ¦ **Banking** â€” Deposits, withdrawals, loans, and weekly interest
- ğŸ² **Tavern Games** â€” Gambling mini-games and resting mechanics
- ğŸ‘‘ **Local Politics** â€” Petitions, decrees, and interactions with the king
- ğŸ“ˆ **Living Economy** â€” Prices and mood drift based on your actions
- â° **Time-Based Events** â€” Day/night cycle affects available activities

</td>
</tr>
<tr>
<td width="50%">

### ğŸ’ **Loot & Equipment**
- ğŸ—¡ï¸ **Procedurally Generated Items** â€” Unique weapons and armor
- âœ¨ **Rarity System** â€” Common to Legendary items with scaling stats
- ğŸ **Equipment Traits** â€” Special effects like on-hit procs
- ğŸ“¦ **Inventory Management** â€” Stackable consumables and gear
- ğŸ’° **Smart Pricing** â€” Dynamic sell values based on item quality

</td>
<td width="50%">

### ğŸ“œ **Quests & Progression**
- ğŸ“– **Quest System** â€” Story-driven and procedural quests
- ğŸ¯ **Multiple Quest Steps** â€” Complex objectives and requirements
- ğŸ… **Rewards** â€” Gold, XP, and unique items
- ğŸ“Š **Character Progression** â€” Level up, distribute skill points
- ğŸ”“ **Unlock System** â€” New abilities at specific levels

</td>
</tr>
</table>

---

## ğŸš€ Quick Start

### ğŸƒ Run Locally

Because Emberwood uses ES modules, you should run it from a local web server.

<table>
<tr>
<td width="50%">

#### ğŸ **Python**

```bash
# Python 3.x
python -m http.server 8000

# Python 2.x
python -m SimpleHTTPServer 8000
```

Then open: `http://localhost:8000`

</td>
<td width="50%">

#### ğŸ“¦ **Node.js**

```bash
# Using npx (no install required)
npx serve .

# Or install serve globally
npm install -g serve
serve .
```

Then open: `http://localhost:3000` (or as shown)

</td>
</tr>
</table>

<details>
<summary>ğŸ’¡ <b>Other Options</b></summary>

#### ğŸ¦€ **Rust (miniserve)**
```bash
cargo install miniserve
miniserve . -p 8000
```

#### ğŸ”µ **PHP**
```bash
php -S localhost:8000
```

#### ğŸŸ¢ **Live Server (VS Code Extension)**
Install "Live Server" extension and click "Go Live" button

</details>

### ğŸ“± iOS / `file://` Note

> âš ï¸ The project includes extra guards for iOS Safari, but **serving from HTTP is still recommended**.  
> Loading modules from `file://` can be inconsistent and surface stricter module semantics.

---

## Deploy to GitHub Pages

Emberwood is a static site. GitHub Pages works well.

### Option A: Deploy from the repo root

1. In GitHub: **Settings â†’ Pages**
2. **Build and deployment â†’ Source:** â€œDeploy from a branchâ€
3. Select branch (e.g. `main`) and folder `/ (root)`
4. Save

### Option B: Deploy from `/docs`

If you prefer keeping source separate from the site output:

1. Move `index.html`, `style.css`, `assets/`, `js/` into `/docs`
2. GitHub: **Settings â†’ Pages â†’ Source:** `main` + `/docs`

### Pathing

All scripts/styles use **relative paths**, so Pages works whether deployed at the root domain or under a repository subpath.

---

## Project layout

Top level:

```
Emberwood_patch_1.2.70_core_systems/
  index.html
  style.css
  assets/
  js/
  README.md
```

JavaScript modules:

- `js/boot/` â€” early boot scripts
  - `bootstrap.js` â€” boot sequencing + optional preflight checks
  - `bootLoader.js` â€” boot overlay + timing
  - `userAcceptance.js` â€” acceptance gate / user prompt logic
  - `lib/safeStorage.js` â€” minimal boot-safe storage wrapper

- `js/shared/` â€” dependency-light utilities shared by boot + game
  - `storage/safeStorage.js`

- `js/game/engine/` â€” orchestration, persistence, UI wiring
  - `engine.js` â€” main entry (state orchestration, gameplay flow)
  - `saveManager.js` â€” save/load + migrations + save-slot helpers
  - `storageRuntime.js` â€” runtime storage diagnostics / safe wrappers
  - `perf.js` â€” performance capture helpers
  - `ui/`
    - `uiRuntime.js` â€” screen switching, modal runtime, log renderer helpers
    - `uiBindings.js` â€” DOM event wiring (menu buttons, HUD gestures, chips)
  - `devtools/`
    - `diagnosticsUI.js` â€” Smoke Tests modal UI + dev pill visibility

- `js/game/data/` â€” large data tables
  - `abilities.js`, `items.js`, `talents.js`

- `js/game/combat/` â€” combat math + runtime helpers
  - `math.js` â€” damage/heal calculations, crit handling, mitigation
  - `statusEngine.js` â€” status ticking / application / stacking rules
  - `abilityEffects.js` â€” ability implementations
  - `postTurnSequence.js` â€” end-of-turn sequencing

- `js/game/systems/` â€” core systems (mostly logic-focused)
  - `timeSystem.js` â€” day/dayâ€‘part handling + normalization
  - `rng.js` â€” deterministic RNG option + logging
  - `lootGenerator.js` â€” item generation pipeline
  - `kingdomGovernment.js` â€” king behavior + decree logic
  - `assertState.js`, `safety.js` â€” invariants and guardrails
  - `enemy/` â€” enemy generation pipeline (templates/rarity/affixes)

- `js/game/locations/village/` â€” village modules
  - `merchant.js`, `bank.js`, `townHall.js`, `tavern.js`, `tavernGames.js`
  - `villageEconomy.js`, `villagePopulation.js`

- `js/game/quests/` â€” quest system
  - `questDefs.js`, `questDefaults.js`, `questBindings.js`
  - `questSystem.js`, `questTriggerRegistry.js`

- `js/game/changelog/` â€” in-game changelog data

---

## Architecture overview

Emberwood is designed around a single **authoritative game state object** plus a set of systems that read/update it.

### Boot sequence

1. `js/boot/bootstrap.js` runs first.
2. A boot overlay is shown and basic diagnostics are captured.
3. If required, user acceptance is handled (`userAcceptance.js`).
4. The game engine entry (`js/game/engine/engine.js`) is imported.

### Engine orchestration

`engine.js` coordinates:

- Building/initializing state
- Calling **saveManager** for load/save/migrate
- Wiring UI via `uiRuntime` + `uiBindings`
- Delegating to systems (time, RNG, loot, quests, village)
- Delegating to combat modules during fights

Key refactors in 1.2.70:

- **Save/migrations** extracted to `saveManager.js`
- **UI runtime + bindings** extracted to `uiRuntime.js` / `uiBindings.js`
- **Diagnostics/QA UI** extracted to `devtools/diagnosticsUI.js`

These extractions reduce circular imports and avoid iOS `file://` pitfalls (temporal dead zones, readâ€‘only imported bindings).

---

## Gameplay systems

### State model & save schema

The game uses one top-level `state` object. The save payload is a normalized subset of runtime state (plus metadata).

Common state buckets:

- `player`: stats, level, HP/resource, inventory, equipment, class config
- `time`: day index + day part
- `combat`: current encounter runtime (only present when in combat)
- `quests`: quest progression data
- `village`: economy + population state
- `government`: decrees/petitions/king state
- `bank`: deposits/loans/interest timing
- `flags`: toggles (dev cheats, deterministic RNG, debug modes)
- `log`: structured log entries + filters
- `ui`: current screen, modal state, UI toggles

Persistence:

- Stored in `localStorage` using safe wrappers (private mode / quota failures are guarded).
- Multiple save slots are supported through an index + per-slot blob keys.

Migration:

- `saveManager.js` applies ordered migrations when loading.
- Migrations normalize missing/older fields and keep forward-compat safety (unknown keys are tolerated).

### Time system & daily ticks

`timeSystem.js` tracks time as **day index** + **day part**.

- `normalizeTime()` clamps time into valid ranges.
- `advanceTime()` advances day-part and wraps to the next day as needed.

Daily ticks:

When time advances in ways that represent a â€œworld tickâ€ (resting, end-of-day), the engine runs a deterministic daily pipeline:

- Economy adjustments
- Merchant restock + pruning
- Decree expiration / effects
- Bank interest timing
- Population mood drift

There is an idempotence guard to prevent â€œdouble tickâ€ bugs.

### RNG & determinism

`rng.js` supports:

- Normal RNG (non-deterministic)
- Deterministic RNG for reproducing bugs
- Optional RNG logging (capped)

This is used across loot rolls, enemy generation, and combat variance.

### Combat

Combat is turn-based and supports single-enemy and multi-enemy battles.

Core components:

- `combat/math.js`: damage/heal computations, crit, mitigation
- `combat/statusEngine.js`: status application and ticking
- `combat/abilityEffects.js`: ability implementations (damage, heal, buffs)
- `combat/postTurnSequence.js`: end-of-turn cleanup, status expiry, intent ticking

Key mechanics:

- **Enemy intent**: enemies can â€œwind upâ€ actions that execute after a countdown.
- **Interrupt**: player can interrupt certain intents (resource cost + posture interaction).
- **Posture**: posture break disrupts enemy intent.
- **AoE**: group abilities apply to all enemies and now correctly resolve multi-enemy defeats.

Safety:

- Damage/heal values are clamped and validated to prevent NaN/Infinity cascades.
- Combat runtime fields are repaired/initialized during load for forward compatibility.

### Abilities & effects

Abilities are defined in `js/game/data/abilities.js` and implemented in `combat/abilityEffects.js`.

Each ability specifies:

- Cost (resource)
- Targeting (self, enemy, group)
- Classification (physical or elemental)
- Effect pipeline (damage/heal + status application)

Effects are kept separate from UI so they can be tested deterministically.

### Status effects & synergies

Status effects are handled by `statusEngine.js`.

Typical status fields:

- `duration` (turns)
- `stacks` or magnitude (where applicable)
- Optional per-turn tick behavior

Synergies (examples):

- Bleed + Fire can ignite (Burning)
- Chilled + Physical can Shatter and consume Chill

### Elements, affinities & resistances

Damage classification:

- Physical or elemental
- Elemental types normalized via helpers to avoid mismatched keys

Enemies:

- Can have affinity multipliers (weakness/resistance)
- Can have flat resist percentages

Players:

- Can gain elemental bonuses/resists from gear and talents
- Elemental resist reduces incoming elemental damage

The combat math stacks affinity and resist effects multiplicatively and avoids printing misleading â€œ0% resistâ€ breakdown lines.

### Classes, resources & progression

Classes define:

- Base stats and growth
- Resource type (e.g., mana)
- Unlock tables (abilities/spells at specific levels)

Progression systems:

- Leveling grants skill points and talent points.
- Cheats can grant max level and auto-distribute skill points (testing).

### Talents

Talents are defined in `js/game/data/talents.js`.

Talents can:

- Modify derived stats immediately
- Add elemental bonuses/resists
- Change combat thresholds (e.g., rhythm mechanics)
- Add conditional passives

Talent changes are applied via stat recomputation to ensure idempotence.

### Items, inventory & equipment

Items are defined in `js/game/data/items.js`.

Inventory rules:

- Stackable items (e.g., potions) normalize to a `quantity` integer.
- Equipment does **not** stack; each piece is an instance.
- Equip/unequip updates derived stats and guards against double-application.
- Selling equipped gear clears the slot and uses centralized `getSellValue`.

Traits:

- Equipment can carry traits that trigger on-hit, on-kill, etc.

### Loot generation

`lootGenerator.js` creates items with:

- Weighted rarity rolls
- Deterministic results under seeded RNG
- Safety guarantees (finite stats, normalized elements)

Loot stress tests ensure the generator remains stable under large batches.

### Enemies, rarity & affixes

Enemy creation is pipeline-driven in `systems/enemy/`:

- `rarity.js`: rarity selection & reward scaling
- `elite.js`: elite/boss rules
- `affixes.js`: affix selection and behavior flags
- `builder.js`: builds a runtime enemy instance from a template
- `display.js`: naming and presentation helpers

Enemies can have:

- Elemental affinities/resists
- Affixes (thorns, vampiric, regenerating, frozen, etc.)
- Difficulty-scaled stats

### Quests

The quest system is split across:

- `questDefs.js`: quest definitions (steps, requirements)
- `questDefaults.js`: default state and flags
- `questBindings.js`: side effects and trigger wiring
- `questTriggerRegistry.js`: registry of trigger types
- `questSystem.js`: lifecycle helpers (init/start/advance/complete)

Design goal: keep quests data-driven, with bindings used only for world integration.

### Village simulation

Village modules live in `js/game/locations/village/`.

Core sub-systems:

- **Merchant (`merchant.js`)**: stock, buy/sell, restock guards, price behavior
- **Economy (`villageEconomy.js`)**: derived multipliers and cost models
- **Population (`villagePopulation.js`)**: mood drift and summaries
- **Bank (`bank.js`)**: deposits/withdrawals, loans, weekly interest timing
- **Town Hall (`townHall.js`)**: petitions and time-limited decrees
- **Tavern (`tavern.js`, `tavernGames.js`)**: resting and gambling mini-games

These are invoked through location UI and through daily tick hooks.

### Logging & UI

UI is separated into runtime vs bindings:

- `uiRuntime.js`:
  - `switchScreen()` with missing-DOM guards
  - modal runtime (open/close, focus trap)
  - log helpers + rendering
  - breakdown formatting helpers used by combat logs

- `uiBindings.js`:
  - Menu buttons (New/Load/Settings)
  - HUD gestures (tap/swipe)
  - Log filter chips (pills)
  - Modal dismissal / close wiring

Log entries are structured with a `type` (system/good/danger) and optional metadata (combat breakdowns, procs, etc.).

### Diagnostics & QA tools

Developer tools are intended for testing and balance work.

- Enable cheats during character creation.
- When enabled, HUD pills appear for:
  - **Cheat Menu**
  - **Smoke Tests & Bug Report**

`devtools/diagnosticsUI.js` owns the Diagnostics modal UI and pill visibility.

Tools included:

- **Smoke Tests**: isolated in-memory QA suite (does not modify the active save)
- **Scenario Runner**: simulates multiple days and loot generation to catch regressions
- **Bug Report Bundle**: exports a JSON bundle (state snapshot + perf + recent log)
- **Perf Snapshot**: boot/FPS summary for profiling
- **Live Save Audit**: checks invariants on the current save

Implementation note (important for iOS Safari):

- QA uses adapters/hooks instead of reassigning imported ES-module bindings, because imported bindings are read-only.

---

## Adding content

### Add an enemy

1. Find the enemy template table (commonly in engine or enemy builder inputs).
2. Add a new template ID and base stats/move list.
3. Use Cheat Menu â†’ spawn/start battle by `templateId`.
4. Iterate until the encounter feels right.

### Add an item

1. Add an entry in `js/game/data/items.js`.
2. Confirm:
   - Inventory display
   - Equip rules (if equipment)
   - Sell value
   - Loot generator behavior
3. Use Cheat Menu to grant by item ID for fast iteration.

### Add an ability

1. Add the ability definition in `js/game/data/abilities.js`.
2. Implement its logic in `js/game/combat/abilityEffects.js`.
3. Add unlock rules for a class if needed.
4. Run Smoke Tests (abilities classification checks will fail fast if misconfigured).

### Add a talent

1. Add the talent in `js/game/data/talents.js`.
2. Ensure it updates derived stats through the stat recompute pipeline.
3. Run Smoke Tests (talent integrity + summary checks will catch many mistakes).

### Add a quest

1. Define in `js/game/quests/questDefs.js`.
2. Add default state in `questDefaults.js`.
3. Bind triggers in `questBindings.js` using the trigger registry.
4. Verify lifecycle with Smoke Tests (quest init/start/advance/complete).

---

## Testing & debugging

### Smoke Tests

Open **Smoke Tests & Bug Report** and click **Run**.

- The suite swaps game state in-memory so it wonâ€™t corrupt your save.
- Mobile runs may default to a â€œquick modeâ€ to keep runtime low.
- Full mode is available for deeper runs.

### Scenario Runner

Use **Scenario** to simulate multiple days and loot batches. This catches:

- Daily tick idempotence bugs
- Economy drift issues
- Loot generator invalid outputs

### Bug reports

Use **Copy JSON** to export a bundle containing:

- Patch label + save schema
- UA/locale
- State snapshot
- Recent input log tail
- Recent game log tail
- Perf snapshot

For reproducible reports:

1. Enable deterministic RNG
2. Set a seed
3. Reproduce
4. Copy JSON and attach to a GitHub issue

---

## Contributing guidelines

### Design goals

- Keep systems small and single-purpose.
- Prefer **pure logic modules** (no DOM) for core mechanics.
- Use UI adapters/hooks rather than importing gameplay code into UI modules.

### iOS / ES module pitfalls to avoid

- **Temporal dead zones**: avoid referencing late-bound functions during module evaluation.
- **Read-only imports**: never assign to an imported binding; use adapters.
- Keep boot + version modules dependency-light.

### Style

- Keep helpers dependency-light.
- Avoid cross-layer imports (systems â†’ UI).
- Add changelog entries for behavior changes and major refactors.

---

## Versioning & releases

### Patch label

The build label lives in `js/game/systems/version.js`:

- `GAME_PATCH`
- `GAME_PATCH_NAME`
- `GAME_FULL_LABEL`

### In-game changelog

Changelog entries live in `js/game/changelog/changelog.js`.

### Save schema

The smoke tests print the current **save schema**. When changing save structure:

- Add/adjust migrations in `saveManager.js`.
- Keep migrations tolerant of unknown keys for forward compatibility.

---

## License

Add a `LICENSE` file that matches your intent (MIT/GPL/Proprietary). If you add thirdâ€‘party assets, list sources and licenses in this README.
